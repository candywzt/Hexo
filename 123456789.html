<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>这是标题 - CandyKing-学习笔记</title>
  <meta charset="UTF-8">
  <meta name="description" content="咸鱼啊">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="https://www.candyking.ml/favicon.ico" type="image/png" />
  <meta name="description" content="这里是文章概述">
<meta property="og:type" content="article">
<meta property="og:title" content="这是标题">
<meta property="og:url" content="https://candywzt.github.io/Hexo/123456789.html">
<meta property="og:site_name" content="CandyKing-学习笔记">
<meta property="og:description" content="这里是文章概述">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-31T15:59:59.000Z">
<meta property="article:modified_time" content="2021-04-20T16:00:00.000Z">
<meta property="article:author" content="CandyKing">
<meta property="article:tag" content="标签1">
<meta property="article:tag" content="标签2">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,gh/theme-nexmoe/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css?v=233" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css">
  
  <link rel="stylesheet" href="/Hexo/css/style.css?v=1619006657098">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/Hexo/" title="CandyKing" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="CandyKing"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/Hexo/" title="CandyKing">
            <img src="https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/avatar.png" alt="CandyKing" alt="CandyKing">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>4</div>
        <div><span>标签</span>2</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/Hexo/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/Hexo/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/Hexo/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/Hexo/archives.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/nexmoe/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/Hexo/tags/%E6%A0%87%E7%AD%BE1/" style="font-size: 10px;">标签1</a> <a href="/Hexo/tags/%E6%A0%87%E7%AD%BE2/" style="font-size: 10px;">标签2</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 CandyKing
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">

  <div class="nexmoe-post-right">
    
      <div class="nexmoe-fixed">
        <div class="nexmoe-valign">
            <div class="nexmoe-toc">
                
                
                  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84C-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">简单的C++程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1、面向过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">2、面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">3、面向对象的三大特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">C++对C的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">1、::作用域运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2、C++命名空间（namespace）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.1.</span> <span class="toc-text">1、命名空间的使用语法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81using%E7%94%B3%E6%98%8E"><span class="toc-number">2.2.2.</span> <span class="toc-text">2、using申明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81using%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.3.</span> <span class="toc-text">3、using编译指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%A5%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">3、严格的类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81struct%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.4.</span> <span class="toc-text">4、struct类型增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%89%E6%9C%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.5.</span> <span class="toc-text">5、三木运算符增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81bool%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">6、bool类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81const%E5%A2%9E%E5%BC%BA"><span class="toc-number">2.7.</span> <span class="toc-text">7、const增强</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%8Bconst"><span class="toc-number">2.7.1.</span> <span class="toc-text">1、C语言下const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81c-%E4%B8%8B%E7%9A%84const"><span class="toc-number">2.7.2.</span> <span class="toc-text">2、c++下的const</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%8B-const%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.</span> <span class="toc-text">C++下 const分配内存的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9const%E5%8F%98%E9%87%8F-%E5%8F%96%E5%9C%B0%E5%9D%80-%EF%BC%8C%E4%BC%9A%E5%88%86%E9%85%8D%E4%B8%B4%E6%97%B6%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">1、对const变量 取地址 ，会分配临时内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F-%E5%88%9D%E5%A7%8B%E5%8C%96-const%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2、使用普通变量  初始化 const变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%AF%94%E5%A6%82%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B9%9F%E4%BC%9A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-number">3.3.</span> <span class="toc-text">3、对于自定义数据类型 ,比如类对象，那么也会分配内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8const%E6%9B%BF%E6%8D%A2%E5%AE%8F-define%E5%B8%B8%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">用const替换宏#define常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81const%E5%92%8C-define%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.</span> <span class="toc-text">1、const和#define区别总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%8F-define%E7%BC%BA%E9%99%B7"><span class="toc-number">4.2.</span> <span class="toc-text">2、宏#define缺陷</span></a></li></ol></li></ol>
                
            </div>
        </div>
      </div>
    
  </div>

  <article>
    
        <div class="nexmoe-post-cover" style="padding-bottom: 62.5%;"> 
            <img data-src="https://img6.bdstatic.com/img/image/pcindex/sunjunpchuazhoutu.JPG" data-sizes="auto" alt="这是标题" class="lazyload">
            <h1>这是标题</h1>
        </div>
    
    
    <div class="nexmoe-post-meta nexmoe-rainbow-fill" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2020年12月31日</a>
    <a><i class="nexmoefont icon-areachart"></i>3.6k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 17 分钟</a>
</div>

    <p>这里是文章概述</p>
<span id="more"></span>

<h1 id="简单的C-程序"><a href="#简单的C-程序" class="headerlink" title="简单的C++程序"></a>简单的C++程序</h1><pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;endl;
    system(&quot;pause&quot;);
    return EXIT_SUCCESS;
&#125;
</code></pre>
<p>分析：</p>
<ul>
<li><code>#include &lt;iostream&gt;</code>; 预编译指令，引入头文件<code>iostream</code>。</li>
<li><code>using namespace std</code>; 使用标准命名空间。</li>
<li><code>cout &lt;&lt; “hello world”&lt;&lt; endl;</code> 和<code>printf</code>功能一样，输出字符串<code>”hello wrold”</code>。</li>
</ul>
<h2 id="1、面向过程"><a href="#1、面向过程" class="headerlink" title="1、面向过程"></a>1、面向过程</h2><p>面向过程是一种以过程为中心的编程思想。  </p>
<p>通过分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。  </p>
<p>面向过程编程思想的核心：功能分解，自顶向下，逐层细化（程序=数据结构+算法）。  </p>
<p>面向过程编程语言存在的主要缺点：不符合人的思维习惯，而是要用计算机的思维方式去处理问题，而且面向过程编程语言重用性低，维护困难。</p>
<h2 id="2、面向对象"><a href="#2、面向对象" class="headerlink" title="2、面向对象"></a>2、面向对象</h2><p><strong>面向对象编程</strong>（Object-Oriented Programming）简称 OOP 技术，是开发计算机应用程序的一种新方法、新思想。</p>
<p>过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继  </p>
<p>使用 OOP 技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级。</p>
<h2 id="3、面向对象的三大特性"><a href="#3、面向对象的三大特性" class="headerlink" title="3、面向对象的三大特性"></a>3、面向对象的三大特性</h2><ul>
<li><p>封装</p>
<p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。  </p>
<p>类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。</p>
</li>
<li><p>继承</p>
<p>继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。  </p>
<p>继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p>
</li>
<li><p>多态</p>
<p>多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。  </p>
</li>
</ul>
<h1 id="C-对C的扩展"><a href="#C-对C的扩展" class="headerlink" title="C++对C的扩展"></a>C++对C的扩展</h1><h2 id="1、-作用域运算符"><a href="#1、-作用域运算符" class="headerlink" title="1、::作用域运算符"></a>1、::作用域运算符</h2><p>如果前面什么都不添加 代表全局作用域</p>
<p>通常情况下，如果有两个同名变量，一个是全局变量，另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p>
<pre><code class="c++">int m=100;  //全局变量
void test()
&#123;
    int m=50;   //局部变量
    cout&lt;&lt;&quot;m=&quot;&lt;&lt;m&lt;&lt;endl;       //输出结果为:m=50
&#125;
</code></pre>
<p>作用域运算符<code>::</code>可解决局部变量与全局变量的重名问题，即在局部变量的作用域内，可用<code>::</code>对被屏蔽的同名的全局变量进行访问。</p>
<pre><code class="c++">int a=60;    //全局变量
void test()
&#123;
    int a=40;    //局部变量
    cout&lt;&lt;&quot;a=&quot;&lt;&lt;::a&lt;&lt;endl;     //::a 引用全局的变量a  输出结果：a=60
&#125;
</code></pre>
<h2 id="2、C-命名空间（namespace）"><a href="#2、C-命名空间（namespace）" class="headerlink" title="2、C++命名空间（namespace）"></a>2、C++命名空间（namespace）</h2><p>名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等  </p>
<p>名称互相冲突性的可能性越大</p>
<p>可以更好地控制标识符的作用域</p>
<ul>
<li>命名空间用途：解决名称冲突</li>
<li>命名空间下可以存放 ： 变量、函数、结构体、类…</li>
<li>命名空间必须要声明在全局作用域</li>
<li>命名空间可以嵌套命名空间</li>
<li>命名空间是开放的，可以随时将新成员添加到命名空间下</li>
<li>命名空间可以匿名的</li>
<li>命名空间可以起别名</li>
</ul>
<h3 id="1、命名空间的使用语法："><a href="#1、命名空间的使用语法：" class="headerlink" title="1、命名空间的使用语法："></a>1、命名空间的使用语法：</h3><ol>
<li><p>创建一个命名空间</p>
<pre><code class="c++">namespace A
&#123;
    int a=15;
&#125;
namespace B
&#123;
    int a=20;
&#125;
void test()
&#123;
    cout&lt;&lt;&quot;A::a=&quot;A::a&lt;&lt;endl;    //输出结果：A::a=15
    cout&lt;&lt;&quot;B::a=&quot;B::a&lt;&lt;endl;    //输出结果：B::a=20
&#125;
</code></pre>
</li>
<li><p>命名空间只能创建在全局范围（以下示例错误）</p>
<pre><code class="c++">void test()
&#123;
    namespace A
    &#123;
        int m=16;
    &#125;
    namespace B
    &#123;
        int m=30;
    &#125;
    cout&lt;&lt;&quot;A::m=&quot;&lt;&lt;A::m&lt;&lt;endl;
    cout&lt;&lt;&quot;B::m=&quot;&lt;&lt;B::m&lt;&lt;endl;
&#125;
</code></pre>
</li>
<li><p>命名空间可以嵌套命名空间</p>
<pre><code class="c++">namespace A
&#123;
    int k=20;
    namespace B
    &#123;
        int k=45;
    &#125;
&#125;
void test()
&#123;
    cout&lt;&lt;&quot;A::k=&quot;&lt;&lt;A::k&lt;&lt;endl;      //运行结果：A::k=20
    cout&lt;&lt;&quot;A::B::k=&quot;&lt;&lt;A::B::k&lt;&lt;endl;   //结果：A::B::k=45
&#125;
</code></pre>
</li>
<li><p>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</p>
<pre><code class="c++">namespace A
&#123;
    int m=50;
&#125;
namespace A
&#123;
    int n=75;
&#125;
void test()
&#123;
    cout&lt;&lt;&quot;A::m=&quot;&lt;&lt;A::m&lt;&lt;endl;    //结果：A::m=50
    cout&lt;&lt;&quot;A::n=&quot;&lt;&lt;A::n&lt;&lt;endl;    //结果：A::n=75
&#125;
</code></pre>
</li>
<li><p>声明和实现可分离</p>
<pre><code class="c++">namespace A
&#123;
    //申明
    int add(int a,int b);
    int sub(int a,int b);
&#125;
//实现
int A::add(int a,int b)
&#123;
    return a+b;
&#125;
int A::sub(int a,int b)
&#123;
    return a-b;
&#125;
void test()
&#123;
    //调用
    cout&lt;&lt;A::add(5,3)&lt;&lt;endl;    //结果：8
    cout&lt;&lt;A::sub(5,3)&lt;&lt;endl;    //结果：2
&#125;
</code></pre>
</li>
<li><p>匿名命名空间</p>
<p>意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了<code>static</code>，使得其可以作为内部连接</p>
<pre><code class="c++">namespace 
&#123;
    int a=50;
    void swap(int &amp;m,int &amp;n)
    &#123;
        int temp=m;
        m=n;
        n=temp；
    &#125;
&#125;
void test()
&#123;
    cout&lt;&lt;&quot;a=&quot;a&lt;&lt;&lt;&lt;endl;     //结果：a=50
    int m=3;
    int n=5;
    cout&lt;&lt;&quot;交换前m=&quot;&lt;&lt;m&lt;&lt;endl;   //结果：交换前m=3 
    cout&lt;&lt;&quot;交换前n=&quot;&lt;&lt;n&lt;&lt;endl;   //结果：交换前n=5
    swap(m,n);
    cout&lt;&lt;&quot;交换后m=&quot;&lt;&lt;m&lt;&lt;endl;   //结果：交换后m=3
    cout&lt;&lt;&quot;交换后n=&quot;&lt;&lt;n&lt;&lt;endl;   //结果：交换后n=5
&#125;
</code></pre>
</li>
<li><p>命名空间别名</p>
<pre><code class="c++">namespace Longnamespace
&#123;
    int m=15;
&#125;
void test()
&#123;
    namespace shortnamespace=Longnamespace;
    cout&lt;&lt;&quot;Longnamespace::m=&quot;&lt;&lt;Longnamespace::m&lt;&lt;endl;     //结果：Longnamespace::m=15 
    cout&lt;&lt;&quot;shortnamespace::m=&quot;&lt;&lt;shortnamespace::m&lt;&lt;endl;   //结果：shortnamespace::m=15  
&#125;
</code></pre>
</li>
</ol>
<h3 id="2、using申明"><a href="#2、using申明" class="headerlink" title="2、using申明"></a>2、using申明</h3><ol>
<li><p>using声明可使得指定的标识符可用。</p>
<p>注意：当using声明与 就近原则同时出现，出错，尽量避免</p>
<pre><code class="c++">namespace A
&#123;
    int m=15;
    int n=20;
    void funcA()&#123;cout&lt;&lt;&quot;funcA函数调用&quot;&lt;&lt;endl;&#125;
    void funcB()&#123;cout&lt;&lt;&quot;funcB函数调用&quot;&lt;&lt;endl;&#125;
&#125;
void test()
&#123;
    //1.通过命名空间作用域运算符访问
    cout&lt;&lt;&quot;A::m=&quot;&lt;&lt;A::m&lt;&lt;endl;    //结果：A::m=15
    A::funcA();                   //结果：funcA函数调用
    //2.通using申明访问
    //int n=30;  //using声明与 就近原则同时出现，出错
    using A::n;
    using A::funcB;
    cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl;          //结果：n=15
    funcB();                      //结果：funcB函数调用
&#125;
</code></pre>
</li>
<li><p>using申明碰到函数重载</p>
<p>如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。</p>
<pre><code class="c++">namespace A
&#123;
    void funcA()&#123;cout&lt;&lt;&quot;无参调用&quot;&lt;&lt;endl;&#125;
    void funcA(int a)&#123;cout&lt;&lt;&quot;传值有参调用&quot;&lt;&lt;endl;&#125;
    void funcA(int *a)&#123;cout&lt;&lt;&quot;传址有参调用&quot;&lt;&lt;endl;&#125;
    void funcA(int &amp;a,int)&#123;cout&lt;&lt;&quot;传引用有参调用&quot;&lt;&lt;endl;&#125;
&#125;
void test()
&#123;
    //using申明
    using A::funcA;
    int a=5;
    funcA();       //结果：无参调用
    funcA(a);      //结果：传值有参调用
    funcA(&amp;a);     //结果：传址有参调用
    funcA(a,5);    //结果：传引用有参调用
&#125;
</code></pre>
</li>
</ol>
<h3 id="3、using编译指令"><a href="#3、using编译指令" class="headerlink" title="3、using编译指令"></a>3、using编译指令</h3><p>using编译指令使整个命名空间标识符可用。</p>
<pre><code class="c++">namespace A&#123;
    int a = 20;
    int b = 30;
    void funcA()&#123; cout &lt;&lt; &quot;hello funcA&quot; &lt;&lt; endl; &#125;
    void funcB()&#123; cout &lt;&lt; &quot;hello funcB&quot; &lt;&lt; endl; &#125;
&#125;

void test01()
&#123;
    //using 编译指令
    using namespace A;
    cout &lt;&lt; &quot;a=&quot;&lt;&lt;a &lt;&lt; endl;
    cout &lt;&lt; &quot;b=&quot;&lt;&lt;b &lt;&lt; endl;
    funcA();
    funcB();

    //不会产生二义性
    int paramA = 30;
    cout &lt;&lt; paramA &lt;&lt; endl;     //就近原则
&#125;

namespace B&#123;
    int a = 20;
    int b = 30;
    void funcA()&#123; cout &lt;&lt; &quot;hello funcA&quot; &lt;&lt; endl; &#125;
    void funcB()&#123; cout &lt;&lt; &quot;hello funcB&quot; &lt;&lt; endl; &#125;
&#125;

void test02()&#123;
    using namespace A;
    using namespace B;
    //二义性产生，不知道调用A还是B的paramA
    //cout &lt;&lt; &quot;a=&quot;&lt;&lt;a &lt;&lt; endl;
    cout&lt;&lt;&quot;A::a=&quot;&lt;&lt;A::a&lt;&lt;endl;
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>当using编译指令  与  就近原则同时出现，优先使用就近</li>
<li>当using编译指令有多个，需要加作用域 区分</li>
</ul>
<h2 id="3、严格的类型转换"><a href="#3、严格的类型转换" class="headerlink" title="3、严格的类型转换"></a>3、严格的类型转换</h2><p>在C++，不同类型的变量一般是不能直接赋值的，需要相应的强转。</p>
<pre><code class="c++">//c代码
int *p=malloc(sizeof(int)*4);

//c++代码
int *p=(int *)malloc(sizeof(int)*4)；
</code></pre>
<h2 id="4、struct类型增强"><a href="#4、struct类型增强" class="headerlink" title="4、struct类型增强"></a>4、struct类型增强</h2><ul>
<li>c中定义结构体变量需要加上<code>struct</code>关键字，c++不需要。</li>
<li>c中的结构体只能定义成员变量，不能定义成员函数。c++即可以定义成员变量，也可以定义成员函数。</li>
</ul>
<pre><code class="c++">//1. 结构体中即可以定义成员变量，也可以定义成员函数
struct Student&#123;
    string mName;
    int mAge;
    void setName(string name)&#123; mName = name; &#125;
    void setAge(int age)&#123; mAge = age; &#125;
    void showStudent()
    &#123;
        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; mName &lt;&lt; &quot; Age:&quot; &lt;&lt; mAge &lt;&lt; endl;
    &#125;
&#125;;

//2. c++中定义结构体变量不需要加struct关键字
void test01()&#123;
    Student student;
    student.setName(&quot;John&quot;);
    student.setAge(20);
    student.showStudent();
&#125;
</code></pre>
<h2 id="5、三木运算符增强"><a href="#5、三木运算符增强" class="headerlink" title="5、三木运算符增强"></a>5、三木运算符增强</h2><ol>
<li><p>c语言三目运算表达式返回值为数据值，为右值，不能赋值。</p>
<pre><code class="c">int a=5;
int b=10;
printf(&quot;%d\n&quot;,a&gt;b?a:b);     //结果：10
//a&gt;b?a:b   返回的是b的值（10）---右值（不可当做左值来被赋值）
(a&gt;b?a:b)=50;   //错误
</code></pre>
</li>
<li><p>c++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。</p>
<pre><code class="c++">int a=5;
int b=10;
printf(&quot;%d\n&quot;,a&gt;b?a:b);    //结果：10
int a=5;
//a&gt;b?a:b   返回的是b变量---左值（可以被赋值）
(a&gt;b?a:b)=50;
cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;
</code></pre>
</li>
</ol>
<h2 id="6、bool类型"><a href="#6、bool类型" class="headerlink" title="6、bool类型"></a>6、bool类型</h2><ul>
<li><code>bool</code>类型只有两个值，true(1值)，false(0值)</li>
<li><code>bool</code>类型占1个字节大小</li>
<li>给<code>bool</code>类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0)</li>
</ul>
<h2 id="7、const增强"><a href="#7、const增强" class="headerlink" title="7、const增强"></a>7、const增强</h2><p><code>const</code>单词字面意思为常数，不变的</p>
<h3 id="1、C语言下const"><a href="#1、C语言下const" class="headerlink" title="1、C语言下const"></a>1、C语言下<code>const</code></h3><p>认为<code>const</code>应该是一个只读变量，既然是变量那么就会给<code>const</code>分配内存，并且在c中<code>const</code>是一个全局只读变量，c语言中<code>const</code>修饰的只读变量是外部连接的。</p>
<ul>
<li><p>全局<code>const</code>   //受常量区的保护</p>
<pre><code class="c">const int a=15;   //全局
//1、直接修改
a=20;    //错误
//2、间接修改
int *p=&amp;a;
*p=20;   //编译通过，运行失败
</code></pre>
</li>
<li><p>局部<code>const</code></p>
<pre><code class="c">void tset()
&#123;
    const int a=15;   //局部  分配到栈上
    //1、直接修改
    a=20;   //失败
    //2、间接修改
    int *p=&amp;a;
    *p=20;  //成功
    printf(&quot;a=%d\n&quot;,a);
&#125;
</code></pre>
<p>​    <code>int arr[a]</code>; 在C语言下 <code>const</code>是伪常量，不可以初始化数组</p>
</li>
<li><p>c语言下<code>const</code>修饰全局变量默认为外部链接属性</p>
<pre><code class="c">//外部文件下
const int g_a = 1000;    //默认是外部链接属性

void test()
&#123;
    extern const int g_a; 
    printf(&quot;g_a = %d\n&quot;, g_a);
&#125;
</code></pre>
</li>
</ul>
<h3 id="2、c-下的const"><a href="#2、c-下的const" class="headerlink" title="2、c++下的const"></a>2、c++下的<code>const</code></h3><p>在c++中，是否为<code>const</code>常量分配内存空间依赖于如何使用</p>
<p>取一个<code>const</code>地址, 或者把它定义为<code>extern</code>,则会为该<code>const</code>创建内存空间</p>
<ul>
<li><p>全局<code>const</code>   //受常量区的保护</p>
<pre><code class="c++">const int a=15;   //全局
//1、直接修改
a=20;    //错误
//2、间接修改
int *p=&amp;a;
*p=20;   //编译通过，运行失败
</code></pre>
</li>
<li><p>局部<code>const</code></p>
<pre><code class="c++">const int b=100;
//1、直接修改
b=50;   //失败
//2、间接修改
int *p=(int *)&amp;b;
*p=50;    //失败
cout&lt;&lt;&quot;b=&quot;&lt;&lt;b&lt;&lt;endl;   //结果：b=100
cout&lt;&lt;&quot;*p=&quot;&lt;&lt;*p&lt;&lt;endl;  //结果：*p=50
</code></pre>
<p><code>int arr[b;</code>   //C++下<code>const</code>修饰的变量 称为常量 ，可以初始化数组  </p>
</li>
<li><p>在c++中，出现在所有函数之外的<code>const</code>作用于整个文件(也就是说它在该文件外不可见)，默认为内部连接，c++中其他的标识符一般默认为外部连接。</p>
<pre><code class="c++">//外部文件下
extern const int g_a = 1000;  //默认是内部链接属性 可以加关键字 extern 提高作用域

void test()
&#123;
    extern const int g_a; 
    printf(&quot;g_a = %d\n&quot;, g_a);
&#125;
</code></pre>
</li>
</ul>
<h1 id="C-下-const分配内存的情况"><a href="#C-下-const分配内存的情况" class="headerlink" title="C++下 const分配内存的情况"></a>C++下 const分配内存的情况</h1><h2 id="1、对const变量-取地址-，会分配临时内存"><a href="#1、对const变量-取地址-，会分配临时内存" class="headerlink" title="1、对const变量 取地址 ，会分配临时内存"></a>1、对const变量 取地址 ，会分配临时内存</h2><pre><code class="c++">void test01()
&#123;
    const int a = 10;
    int * p = (int *)&amp;a;
&#125;
</code></pre>
<h2 id="2、使用普通变量-初始化-const变量"><a href="#2、使用普通变量-初始化-const变量" class="headerlink" title="2、使用普通变量  初始化 const变量"></a>2、使用普通变量  初始化 const变量</h2><pre><code class="c++">void test02()
&#123;
    int a = 10;
    const int b = a;

    int *p = (int *)&amp;b;
    *p = 1000;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="3、对于自定义数据类型-比如类对象，那么也会分配内存"><a href="#3、对于自定义数据类型-比如类对象，那么也会分配内存" class="headerlink" title="3、对于自定义数据类型 ,比如类对象，那么也会分配内存"></a>3、对于自定义数据类型 ,比如类对象，那么也会分配内存</h2><pre><code class="c++">struct Person
&#123;
    string m_Name;
    int m_Age;
&#125;;
void test03()
&#123;
    const Person p;
    //p.m_Age = 10;    //不可修改

    //指针间接修改
    Person * pp = (Person *)&amp;p;
    (*pp).m_Name = &quot;Tom&quot;;
    pp-&gt;m_Age = 10;

    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;
&#125;
</code></pre>
<h1 id="用const替换宏-define常量"><a href="#用const替换宏-define常量" class="headerlink" title="用const替换宏#define常量"></a>用const替换宏#define常量</h1><h2 id="1、const和-define区别总结"><a href="#1、const和-define区别总结" class="headerlink" title="1、const和#define区别总结"></a>1、const和#define区别总结</h2><ol>
<li><code>const</code>有类型，可进行编译器类型安全检查。<code>#define</code>无类型，不可进行类型检查。</li>
<li><code>const</code>有作用域，而<code>#define</code>不重视作用域.</li>
</ol>
<h2 id="2、宏-define缺陷"><a href="#2、宏-define缺陷" class="headerlink" title="2、宏#define缺陷"></a>2、宏<code>#define</code>缺陷</h2><ol>
<li><p>无类型</p>
</li>
<li><p>宏常量不重视作用域.</p>
<pre><code class="c++">void func1()
&#123;
    const int a = 10;
    #define A 20 
    //#undef A  //卸载宏常量A
&#125;
void func2()
&#123;
    //cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; //不可访问，超出了const int a作用域
    cout &lt;&lt; &quot;A:&quot; &lt;&lt; A &lt;&lt; endl; //#define作用域从定义到文件结束或者到#undef，可访问
&#125;
</code></pre>
</li>
<li><p>宏常量不可以有命名空间</p>
<pre><code class="c++">namespace MySpace
&#123;
    #define num 1024
&#125;
void test()
&#123;
    //cout &lt;&lt; MySpace::num &lt;&lt; endl; //错误
&#125;
</code></pre>
</li>
</ol>

  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>CandyKing<br>
    <strong>本文链接：</strong><a href="https://candywzt.github.io/Hexo/123456789.html" title="https:&#x2F;&#x2F;candywzt.github.io&#x2F;Hexo&#x2F;123456789.html" target="_blank" rel="noopener">https:&#x2F;&#x2F;candywzt.github.io&#x2F;Hexo&#x2F;123456789.html</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/Hexo/tags/%E6%A0%87%E7%AD%BE1/" rel="tag">标签1</a> <a class="nexmoefont icon-tag-fill -none-link" href="/Hexo/tags/%E6%A0%87%E7%AD%BE2/" rel="tag">标签2</a>
    
</div>

  <div class="nexmoe-post-footer">
    
  </div>
</div>
        <!--<div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool">
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>-->
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script>
	hljs.initHighlightingOnLoad();
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>
 

<script src="/Hexo/js/app.js?v=1619006657100"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>

  





</body>

</html>
